# LabWork1Var13
1 - 14) 
"Приведите синтаксис условного оператора в общем виде.Проиллюстрируйте его фрагментом программы на языке C#."
Условный оператор ( ? : ) , известный как тернарный условный оператор, вычисляет логическое выражение и возвращает результат 
вычисления одного из двух выражений, в  зависимости от того, чему равно значение логического выражения: true или false. Для условного
оператора используется следующий синтаксис: condition ? consequence : alternative.
В следующем примере иллюстрируется использование условного оператора:

double sinc(double x) => x != 0.0 ? Math.Sin(x) / x : 1;

Console.WriteLine(sinc(0.1));
Console.WriteLine(sinc(0.0));
// Output:
// 0.998334166468282
// 1

2 - 3)
"Возможно ли создание гетерогенных приложений в среде .NET?"
Да. 

3 - 16)
"Что понимается под термином «пространство имен»?"
Пространство имён (англ. namespace) — некоторое множество, под которым подразумевается модель, абстрактное хранилище или окружение, созданное для логической группировки уникальных идентификаторов (то есть имён).В языке C# существуют пространства имён, употребление аналогично C++.

4 - 5)
"Является ли среда CLR многоязычной?"
Да.

5 - 18)
"Благодаря какому механизму удается избежать коллизий имен в
языке C#?"
Проблема коллизии имен возникает, когда два или более интерфейса имеют методы с одинаковыми именами и сигнатурой. Если имена методов совпадают, но сигнатуры разные, то это не приводит к конфликтам — при реализации у класса наследника просто появляются перегруженные методы.Но что следует делать классу-наследнику в тех случаях, когда сигнатуры методов совпадают? И здесь возможны две стратегии — склеивание методов и переименование.

Стратегия склеивания применяется тогда, когда класс — наследник интерфейсов — полагает, что разные интерфейсы задают один и тот же метод, единая реализация которого и должна быть обеспечена наследником. В этом случае наследник строит единственную общедоступную реализацию, соответствующую методам всех интерфейсов, которые имеют единую сигнатуру.

Другая стратегия исходит из того, что, несмотря на единую сигнатуру, методы разных интерфейсов должны быть реализованы по-разному. В этом случае необходимо переименовать конфликтующие методы. Конечно, переименование можно сделать в самих интерфейсах, но это неправильный путь: наследники не должны требовать изменений своих родителей — они сами должны меняться. Переименование методов интерфейсов иногда невозможно чисто технически, если интерфейсы являются встроенными или поставляются сторонними фирмами. К счастью, мы знаем, как производить переименование метода интерфейса в самом классе наследника, для этого достаточно реализовать методы разных интерфейсов как закрытые, а затем открыть их с переименованием.



